package com.bankingmanagement.authservice.dto;

/*
╔══════════════════════════════════════════════════════════════════════════════════════════╗
║                              REGISTER REQUEST DTO                                         ║
║                                                                                           ║
║  BUILD ORDER: STEP 4a of 12 (First DTO)                                                  ║
║  PREVIOUS STEP: Entities (Step 3) - Domain model must exist first                        ║
║  NEXT STEP: Other DTOs (LoginRequest, AuthResponse, etc.)                                ║
║                                                                                           ║
║  WHY DTOs COME AFTER ENTITIES:                                                           ║
║  - DTOs define the API contract (what clients send/receive)                              ║
║  - They're designed BASED ON the domain model (entities)                                 ║
║  - Separation of concerns: Entities = DB, DTOs = API                                     ║
║  - We need to know what User entity contains before designing registration form          ║
║                                                                                           ║
║  WHY SEPARATE DTOs FROM ENTITIES?                                                        ║
║  ┌─────────────────────────────────────────────────────────────────────────────────────┐ ║
║  │  Anti-Pattern (DON'T DO THIS):                                                      │ ║
║  │  @PostMapping("/register")                                                          │ ║
║  │  public User register(@RequestBody User user) { ... }  // DANGEROUS!               │ ║
║  │                                                                                     │ ║
║  │  Problems:                                                                          │ ║
║  │  1. Client could set User.id (mass assignment vulnerability)                        │ ║
║  │  2. Client could set User.roles = ADMIN (privilege escalation)                      │ ║
║  │  3. Client sees database fields in API docs                                         │ ║
║  │  4. DB schema changes break the API                                                 │ ║
║  │                                                                                     │ ║
║  │  Correct Pattern (OUR APPROACH):                                                    │ ║
║  │  @PostMapping("/register")                                                          │ ║
║  │  public AuthResponse register(@RequestBody RegisterRequest dto) { ... }            │ ║
║  │                                                                                     │ ║
║  │  Benefits:                                                                          │ ║
║  │  1. Only allowed fields can be set (whitelist approach)                             │ ║
║  │  2. Validation rules specific to registration                                       │ ║
║  │  3. API contract independent of DB schema                                           │ ║
║  │  4. Clear documentation via validation annotations                                  │ ║
║  └─────────────────────────────────────────────────────────────────────────────────────┘ ║
║                                                                                           ║
║  VALIDATION ANNOTATIONS EXPLAINED:                                                       ║
║  - @NotBlank: Not null AND not empty AND not just whitespace                            ║
║  - @Size: Min/max length for strings                                                    ║
║  - @Pattern: Regex validation                                                           ║
║  - @Email: Valid email format (from jakarta.validation)                                 ║
║                                                                                           ║
║  These annotations trigger when @Valid is used in the controller:                        ║
║  public AuthResponse register(@Valid @RequestBody RegisterRequest request) { ... }       ║
╚══════════════════════════════════════════════════════════════════════════════════════════╝
*/

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for user registration requests.
 * 
 * This class defines what data a new user must provide to create an account.
 * Validation ensures data quality before it reaches the service layer.
 * 
 * WHAT'S NOT INCLUDED (by design):
 * - id: Generated by server
 * - roles: Default to ROLE_USER (can't self-assign ADMIN)
 * - enabled: Default to true
 * - createdAt: Set by server
 * 
 * WHAT'S OPTIONAL:
 * - firstName, lastName: Profile info (can add later)
 * - phoneNumber: Optional contact (can add later)
 */
@Data       // Lombok: Generates getters, setters, equals, hashCode, toString
@Builder    // Lombok: Enables builder pattern: RegisterRequest.builder().username("john").build()
@NoArgsConstructor  // Lombok: Required for Jackson deserialization
@AllArgsConstructor // Lombok: Constructor with all fields
public class RegisterRequest {

    /**
     * Unique username for the account.
     * 
     * VALIDATION RULES:
     * - Required (can't be blank)
     * - 3-50 characters
     * - Only alphanumeric + underscore (no spaces, no special chars)
     * 
     * WHY THESE RULES?
     * - Min 3: Avoid single-letter usernames
     * - Max 50: Matches database column size
     * - Alphanumeric only: Safe for URLs, mentions, etc.
     */
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Username can only contain letters, numbers, and underscores")
    private String username;

    /**
     * Email address for the account.
     * 
     * Used for:
     * - Alternative login method
     * - Password reset (future)
     * - Notifications (future)
     */
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;

    /**
     * Password for the account.
     * 
     * VALIDATION RULES:
     * - Min 8 characters (NIST recommends 8+)
     * - At least one uppercase letter
     * - At least one lowercase letter
     * - At least one digit
     * - At least one special character (@$!%*?&)
     * 
     * WHY THESE RULES?
     * - Prevents weak passwords
     * - Industry standard complexity requirements
     * - Balance between security and usability
     * 
     * REGEX BREAKDOWN:
     * ^                    - Start of string
     * (?=.*[a-z])          - Lookahead: at least one lowercase
     * (?=.*[A-Z])          - Lookahead: at least one uppercase
     * (?=.*\d)             - Lookahead: at least one digit
     * (?=.*[@$!%*?&])      - Lookahead: at least one special char
     * [A-Za-z\d@$!%*?&]+   - Match characters from allowed set
     * $                    - End of string
     */
    @NotBlank(message = "Password is required")
    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters")
    @Pattern(
            regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$",
            message = "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character"
    )
    private String password;

    // ========================= OPTIONAL PROFILE FIELDS =========================
    /*
     * These fields are optional during registration.
     * Users can add/update them later via profile settings.
     */

    @Size(max = 50, message = "First name must not exceed 50 characters")
    private String firstName;

    @Size(max = 50, message = "Last name must not exceed 50 characters")
    private String lastName;

    /**
     * Phone number in E.164 format.
     * 
     * REGEX: ^\\+?[1-9]\\d{1,14}$
     * - Optional + prefix
     * - First digit must be 1-9 (no leading zero)
     * - 1-14 more digits
     * - Total: 2-15 digits (E.164 max is 15)
     * 
     * Examples: +14155551234, 14155551234, +442071234567
     */
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Invalid phone number format")
    private String phoneNumber;
}
